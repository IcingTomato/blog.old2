---
layout: post
title: "Easy C Language"
description: "よくわかるC言語"
comments: false
keywords: "C"
---

![](//panzhifei.fun/img/2021/03/31/01/title_c.jpg)

この連載に目を止め，「読んでみようか」と思ってくれた皆さんは，これまで，どんなプログラム言語の経験があるでしょうか？ 「JavaScriptなどのWeb系のスクリプト言語はよく使う」，「Visual BasicやJavaでアプリケーションを作っているのだけど，基本を確認したくて…」，あるいは「連載1回目だし，これからプログラミングを学びたい」など，いろいろな方がいらっしゃると思います。

　本連載は，「C言語」というプログラミング言語の“定番”を通して，あらゆるプログラミングに共通する基礎となる部分を，じっくり解説していきます。初心者の方はもちろん，プログラミング経験のある方も自分の知識を再確認するのにきっと役立つと思います。

<center>☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</center>
<center>☆　　 　　　タイトル　　　 　　☆</center>
<center>☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</center>

- [第1回　もう一度，C言語から始めよう　](#title1)
- [第2回　変数の性質を理解しよう　](#title2)
- [第3回　制御構文がわかればプログラムの「流れ」がわかる　](#title3)
- [第4回　変数のスコープをアドレスを使って理解する](#title4)　
- [第5回　配列を理解してアルゴリズムを考える　](#title5)
- [第6回　ポインタを理解して文字列を扱う　](#title6)
- [第7回　再帰処理と参照渡し（モドキ）のメリット・デメリット　](#title7)
- [第8回　構造体でデータをスッキリと扱う　](#title8)
- [第9回　動的なメモリーの確保とリスト処理　](#title9)
- [第10回　定番の関数を覚えればファイル処理などカンタンだ　](#title10)
- [第11回　ランダム・アクセスとバイナリ・ファイルの扱いを学ぶ　](#title111)
- [第12回　構造体に手足を付ければ，それがクラスだ　](#title12)
- [コメント](#title13)

# <span id="title1">第1回　もう一度，C言語から始めよう</span>

## コンピュータはマシン語しか理解しない

　皆さんは，そもそもコンピュータは何語で動いているのかわかりますか？ 日本人にとっての母国語が日本語で，英国人にとってのそれが英語であるように，コンピュータにとっての母国語は機械語（マシン語）です＊1。人間は，必要に迫られれば学習し，カタコトでも他国語を話せるようになりますが，コンピュータはちっとも自発的に学習してくれません。何年たっても，マイクロプロセサが直接に解釈・実行できる言語はマシン語だけです（多くの日本人が，中学からずーっと英語を勉強しているわりに，英語を話せないという事実はまあ，それはおいといて…）。

　マシン語というと，何か意味のある言葉のようなイメージがしますが，デジタル機器であるコンピュータの中では，プログラムも含め，あらゆる情報が2進数で表現されています。ですから，マシン語は人間の目には単なる数字の羅列にしか映りません。例えばこんな感じです。

```
　4D 5A 44 01 12 00 12 00 20 00 FF …
```

マシン語プログラムを16進数＊2で表示させると，上記のように数字が並んでいるだけなのです。

　かつて，「コンパイラ」や「インタプリタ」という名前の便利な道具が存在しない時代がありました。そのころは，人間がこのマシン語でプログラムを記述していたのです。「4D5Aと書くと×××が○○○になるから，次は4401で△△△して…」と人間にとっては意味を見出せない数字の羅列でプログラムを作っていた――今，考えるとぞっとする作業ですね。

　そこで，人間にわかりやすい文字で書いたものをマシン語に変換（翻訳）するプログラムが開発されました。それが「アセンブリ言語」です。アセンブリ言語では「ニーモニック」という英単語を略式化したような記号でプログラムを記述します。例えば以下のような感じです。

```x86asm
　push ebp

　mov ebp,esp

　xor edx,edx

　mov eax,1
　…
```

このニーモニック・コードで記述されたプログラムを，「アセンブラ」という別のプログラムがマシン語に翻訳するのです。アセンブラは，ニーモニック・コードをマシン語に1対1で翻訳するプログラムです。ADD（加算），CMP（比較），DIV（除算），INC（＋1する），DEC（－1する），JMP（無条件ジャンプ），MOV（データの転送）――といった命令が用意されています。

　アセンブリ言語を使えば，数字の羅列に比べてだいぶプログラムを読み書きやすくはなりました。しかし，しょせんアセンブリ言語も，基本的にはマシン語と1対1で対応しているに過ぎません。複雑なロジックを書くには面倒だということは想像がつくでしょう。わかりやすくなったけど，プログラミングはやっぱり大変な作業であるという状態ですね。

## C言語はプログラマの共通語

　やがて，大規模なプログラムを，もっと効率よく，もっと簡単に作成できないかと，より自然言語＊3に近い言葉でプログラムを記述するためのプログラミング言語（高級言語）の開発が始まりました。科学技術計算に向くFORTRAN，プログラミング初心者に適したBASIC，小数の計算が正確で事務処理に向くCOBOL，明確な文法を持つPascal――など1950年代ごろから，様々な高級言語が生まれました。

　そして1970年ごろ，これから本連載で皆さんが学ぶC言語が登場したのです。C言語は当初，UNIXというOSを開発するために作られました。しかしC言語が備える機能が強力だったため，UNIX上で動作するプログラムの開発や，Windowsにも使われていくようになりました。現在，Windows用のソフトウエア開発で，C言語が一番使われているというわけではありません。それでも，現在利用されている多くのプログラミング言語は，C言語の影響を少なからず受けています。

　C言語をオブジェクト指向化したC++や .NET対応のC#は当然C言語の流れをくんでいます。Javaもそうです。Webアプリケーションで使われているPerl，PHP（PHP：Hypertext Preprocessor），JavaScriptなどもC言語の影響を強く受けています。

　つまりC言語をマスターすれば，プログラミングに必要な基礎が身に付くとともに，現在注目を浴びている言語を学ぶ足がかりができるのです。今のC言語は，プログラミングを深く理解するうえでの共通言語に成っているといえなくもないでしょう。

## C言語はコンパイラを使う

　さて，高級言語には，書いたプログラムをマシン語に翻訳するのに大きく2種類の方法，インタプリタとコンパイラがあります（図1）。図1上のインタプリタでは，プログラム実行時に1行ずつ翻訳を行います。翻訳－実行を1ステップ（1行）ごとに繰り返すわけです。実行するたびに翻訳する手間がありますから，処理速度はあまり速くはありません。でも，プログラムのバグ＊4を見つけて修正したら，すぐに再実行できるという利点があります。短いプログラムを作成する場合や，プログラミングの学習に適しています。

![](http://panzhifei.fun/img/2021/03/31/01/zu01.jpg)
*図1●インタプリタとコンパイラ*

一方，図1下のコンパイラは，マシン語にプログラムを翻訳して，実行可能なファイルを作成します。プログラムに文法上の間違いがあった場合は，コンパイラがコンパイル・エラーとして出力するので，エラー・メッセージの内容を分析してプログラム上のミスを修正し，再度コンパイルしてプログラムを作っていきます。実行速度は翻訳の手間が必要ないぶんだけ，一般にインタプリタに比べて高速です。C言語は，こちらのコンパイラ方式を採用しています。

　ちなみにJavaや .NETに対応したプログラミング言語（C#，Visual Basic .NETなど）も，コンパイラを利用します。ただし，これらのコンパイラは特定のOSに依存するマシン語を作成するのではなく，代わりに「中間コード」というものを出力します。出力された中間コードは，Javaなら，Java VM＊5というJavaプログラム専用の実行環境上で，.NETなら .NET Framework上＊6でマシン語に翻訳され実行されます。実行環境がOSの違いを吸収してくれるので，同じプログラムが別の種類のコンピュータ上でも動作できる仕組みなわけです。

**なにはともあれ**

## コンパイラをインストールする

　プログラミング言語の学習で一番大事なことは，実際に“自分の手を使って”プログラムを作成し，コンパイル・実行してみることです。読むだけではだめです。本連載でも，皆さんが実際に手を動かしながら学んでいけるようにしていきますので，どうぞ試してみてください。

　本連載で利用するC言語のコンパイラは「Borland C++ Compiler 5.5」です。ボーランドが[Webサイト](http://www.borland.co.jp/cppbuilder/freecompiler/)で無償公開しています。このコンパイラを使えば，Windows 95/98/MeのMS-DOSプロンプトや，Windows XPなどのコマンドプロンプト上で，C言語あるいはC++言語で記述したソース・プログラムをコンパイルできます。

まずはインストールしましょう。今回はWindows XPにインストールする手順を説明しますが，Windows 2000や98/Meでも利用できます[＊7](#jump7)。インストール後に必要な設定がありますので，読み飛ばさずにゆっくりお付き合いください。

　ダウンロードした「freecommandlinetools2.exe」をダブルクリックすると，インストーラが起動します。使用許諾契約のダイアログが表示されますので，同意して，インストールするフォルダを選択してください。デフォルトはc:\borland\bcc55です。特に理由がない限り，そのままがよいでしょう。インストールが終わると，c:\borland\bcc55にいろいろなファイルが作成されます。「readme.txt」というファイルに必要な設定が書いてありますので，メモ帳などのエディタで開いて読んでください。

　readme.txtの「2.のa.」という欄に「既存のパスに "c:\Borland\Bcc55\bin" を追加します」とあります。パス（path）という言葉がはじめてだと，目的が理解しにくいと思いますので，簡単に解説しておきましょう。

　コマンドプロンプトを起動して，カーソルが点滅している部分に次のコードを入力してEnterキーを押してください。

　**cd \borland\bcc55\bin**

cdとは，ユーザーが作業を行うフォルダ（カレント・ディレクトリ）を移動する，MS-DOSのcd（change directory）コマンドのことです。コマンドプロンプトには「C:\cd \borland\bcc55\Bin＞」という文字が出て，カーソルが点滅していると思います。つまり，カレントディレクトリが，c:\borland\bcc55\binに移動したわけです。

　実はBorland C++ Compiler 5.5の本体であるコンパイラ・プログラムは，このフォルダの中にある「bcc32.exe」ファイルです。ですからここで，

　**bcc32**

と入力すると，コンパイラ・プログラムを起動できます。でも，コンパイラ・プログラムを起動するために，いちいちc:\borland\bcc55\binにカレント・ディレクトリを移動するのは面倒ですよね。フォルダを新たに作って，そこにプログラム・ファイルを保存したいと思うでしょう。

　そこでパスの設定が必要になります。というのも，c:\borland\bcc55\bin以外のほかのフォルダがカレント・ディレクトリになっている場合は，bcc32.exeがどこにあるか，Windowsが理解できなくなってしまうからです。Windowsには，「c:\Borland\Bcc55\binにbcc32.exeがあるよ」と教えてやらなければなりません。そうしないと「bcc32.exeが見つからないよ」というエラーになります。

　パスを設定するには，Windows 2000/XPの場合，マイコンピュータを右クリックし，プロパティを選びます。詳細設定（Windows 2000の場合，詳細）タブを選び，環境変数ボタンを押します。続いてシステム環境変数のPathを選び，編集ボタンを押します。変数値（Windows 2000の場合，値）の末尾に，すでに入力されている文字列に続けて

　**;C:\borland\bcc55\Bin**

と入力してください。これでOKボタンを押して登録すれば，どこのフォルダがカレントになっていても，bcc32.exeを実行できるようになります。なお，この変更は次にコマンドプロンプトを起動したときに有効になります。

　もう一つやっておくことがあります。readme.txtの「2のbとc」に，「bcc32.cfgとilink32.cfgというファイルを作るように」と書いてあります。bcc32.cfgファイルの目的は，コンパイラに「インクルード・ファイル」と「ライブラリ・ファイル」というファイル群の存在する場所を指定することです。

　bcc32.cfgを作らないと，コンパイルできないというわけではないのですが，作らない場合はコンパイルを行うたびに，インクルード・ファイルとライブラリ・ファイルの場所を指定しなければなりません。bcc32.cfgという設定ファイルを作っておけば，コンパイルが容易になるのです。

　readme.txtの

　**-I"c:\Borland\Bcc55\include"**

　**-L"c:\Borland\Bcc55\lib"**
という2行をコピーして，テキスト・エディタの別のウィンドウにペーストします。そしてファイル名を「bcc32.cfg」として，c:\borland\bcc55\Binフォルダに保存します。

　同様に

　**-L"c:\Borland\Bcc55\lib"**

の1行も，コピーアンドペーストして，ilink32.cfgというファイル名で同じフォルダに作成してください。

　それから，c:\borlandの中に，ソース・プログラムを入れておく場所として，srcなどの名前でサブ・フォルダを作っておくとよいでしょう＊8。これで準備はOKです。

## 最初のプログラムを作って実行する

　さて，いよいよC言語のプログラムを書いてみましょう。

　ソース・プログラムはエディタと呼ばれるソフトウエアを使って書きます。いつもお使いのエディタがあれば，それをお使いください。何もなければ，メモ帳でも構わないのですが，インターネットで「エディタ　フリー」などのキーワードで検索してC言語のソース・プログラム編集に適したものをダウンロードされるとよいでしょう。

　それでは最初のプログラムを書いて，コンパイル/実行してみましょう（リスト1）。画面にHelloと表示するだけのプログラムです。c:\borland\srcにエディタで作成して「hello.c」というファイル名で保存します。C言語のソース・プログラムだから拡張子はcになります。

![](http://panzhifei.fun/img/2021/03/31/01/list01.jpg)
*リスト1● 最初のC言語のプログラム。画面に 「Hello」と表示する*

ここでコマンドプロンプトを起動し，カレント・ディレクトリをc:\borland\srcに移動して（前述のcdコマンドを使って），

　**bcc32 hello.c**

と入力してコンパイルします（図2）。コンパイル・エラーがなければ，hello.exeという実行ファイルが作成されます。

![](http://panzhifei.fun/img/2021/03/31/01/zu02.jpg)
*図2●リスト1のプログラム（hello.c）をコンパイルする様子*

　作成したプログラムを実行するには，

　**hello**

と入力します（**図3**）。画面にHelloと表示されました。

![](http://panzhifei.fun/img/2021/03/31/01/zu03.jpg)
*図3●コンパイルしたhello.cを実行した*

　ここで一つ，覚えておいていただきたいことがあります。実はコンパイル処理だけで実行ファイルができるのではありません。自分の書いたソース・プログラムをコンパイラがオブジェクト・ファイル（マシン語に翻訳されている）として出力します。そのオブジェクト・ファイルを，リンカーというプログラムが，標準ライブラリとリンク（結合）して，実行ファイル（この場合ならhello.exe）を作成します（**図4**）。Borland C++ Compilerでは，オプションで「コンパイルのみ」を指定しない限り，エラーがなければ，自動的にリンク処理が呼び出されます。bcc32.cfg ファイルに

**-L"c:\Borland\Bcc55\lib"**

と記述したのは，標準ライブラリの場所を示すためだったのです。

![](http://panzhifei.fun/img/2021/03/31/01/zu04.jpg)
*図4●オブジェクト・ファイルと標準ライブラリ・ファイルをリンカーがリンクして実行ファイルを生成する*

## プログラムを読んでみる

　連載1回目ですから，あまりややこしい話はしたくないのですが，ソース・プログラムの説明をしないわけにはいかないので，少し我慢してお付き合いください。

　C言語は「構造型言語」と呼ばれます。アセンブリ言語のように，コードをズラズラと続くような書き方はしません。プログラムは一つ以上の複数の関数で構成されます。リスト1をもう一度見てください。

　まず，mainという名前の関数(2)が必要です。関数の始めと終わりは(3)と(6)のように「{」と「}」で示します。プログラムはmain関数の1行目から実行されます。このサンプルでは(4)のprintf関数から実行されます。printf関数は「標準ライブラリ」に登録されている関数です。標準ライブラリは，画面への表示のように，プログラマの誰もがよく使う処理を集めた道具箱のようなものです。

　printf関数は，ダブルクォーテーション（"）に囲まれた文字列を出力します。リンカーが標準ライブラリの一部を，自分の作ったプログラムにくっつけてくれるので，printf関数を使って画面に文字列を出力できるのです。

　標準ライブラリとして，多くの関数が用意されていることがアセンブリ言語に比べて，プログラミングの効率が良い理由の一つです。C言語では，用意されている（あるいは自分で作った）関数を組み合わせて，プログラムを構成していくわけです。

　ソースコードの1行はセミコロン（;）で終わります。関数は，中学校の数学の授業で習った関数と同じで，値を返します。(5)のreturn文が0という値を返しています。

　(1)の「#」ではじまる命令はプリプロセッサ命令と呼ばれ，Cコンパイラがソース・プログラムを解釈する前に実行されます。#includeは＜と＞の中に書かれている拡張子.hのヘッダー・ファイルをインクルード（取り込み）します。stdio.hに書いてある内容が，そのまま自分のプログラムの中に展開されるのです。bcc32.cfgに記述した

　**-I"c\Borland**

　**\Bcc55\include"**

は，このヘッダー・ファイルのありかを示していたのです。
　これで，プログラムを作成し，コンパイル，実行するまでの手順がおわかりいただけたと思います。次に，ちょっと面白いことをしてみましょう。

## アセンブリ・コードと比べてみる

　Cコンパイラの多くは，アセンブリ・リストを出力する機能を備えています。C言語で書いたソースコードをアセンブリ言語のコードとして出力することができるのです。例えばBorland C++ Compilerでは，次のようにオプションに「-S」を指定すると，アセンブリ・コードを出力してくれます。

　**bcc32 -S hello.c**

なお，オプションの指定では，大文字と小文字が区別されますので注意してください。

　実際に実行してみると，この例では，hello.asmというファイルが作成されます。一部を抜粋してみました（リスト2）。構成がわかりにくいかもしれませんが，セミコロンに続くコードが元のCのコードで，それ以外の部分がアセンブリ言語のコードです。

![](http://panzhifei.fun/img/2021/03/31/01/list02.jpg)
*リスト2●hello.cから生成したアセンブリ・コード*

なにやらズラズラと書いてありますが，コードの内容がわからなくても大丈夫です。冒頭で説明したように，ニーモニック・コードとマシン語は1対1で対応します。しかし，Cのコードとアセンブリ言語のコードは1対1にはなっていませんね。C言語のコード1行から，複数行のアセンブリ・コードが出力されています。

　ソースコード1行から，複数行のアセンブリ・コード，つまりマシン語が出力されるのですから，C言語はアセンブリ言語よりもプログラムの開発効率が高いということができます。「C言語って，マシン語やアセンブラでプログラムを作るよりも便利なんだ」――そう感じてもらえれば，連載第1回の目標は達成です。

# <span id="title2">第2回　変数の性質を理解しよう</span>

皆さん，こんにちは。この連載「よくわかるC言語」は，今回が2回目です。前回はC言語のソース・プログラムをアセンブラのコードとして出力して，Cのソースコード1行が複数のアセンブラのコードに対応していることを確認しました。なるほどC言語は“高級”な言語なのだと，感じていただけたのではないでしょうか。

　さて，皆さんがプログラミングをしていて，“こう書くとこうなるけど，その理由はわからない”という方はいらっしゃいませんか。でもあまり心配する必要はありません。なぜそうなるのかの理由がわからないのは，たぶんプログラミングがわからないのではなくて，コンピュータの動作原理などの基礎知識が不足しているだけです。今回のテーマは「変数」ですが，この“コンピュータの仕組み”に重点を置いて説明していきます。ぜひ最後まで読んでみてください。ぼんやりしていた部分がはっきりすることでしょう。

## 変数はメモリーの一部に名前を付けたもの

　では早速始めます。変数そのものを解説する前に，プログラムが扱う様々なデータを，コンピュータがどのように“記憶”するかを確認するところからお話ししましょう。

　コンピュータがデータを記憶するには，メモリーかハードディスクを利用します。メモリーは，CPUが直接アクセスできる記憶装置です。半導体素子を利用して，データを電気的に記録します。動作は高速ですが，電源を切ると内容が失われてしまいます。情報処理の用語では「主記憶装置」と呼ばれています。

　電源が切れたら消えてしまうと困るようなデータを記憶させるときには，皆さんご存じのハードディスクを利用します。フロッピ・ディスクやCD-Rなどを利用することもありますね。これらは「補助記憶装置」と呼ばれています。

　ちょっと当たり前すぎて簡単に感じられたかもしれません。ここからが大事なところです。補助記憶装置に記憶されたデータをコンピュータが利用するときには，必要なものだけを主記憶装置（メモリー）に読み込んで利用します。やみくもに読み込むだけでは，何がどのデータだかわかりにくくなってしまいます。なのでプログラミング言語からは，メモリーの一部を，自分が付けた名前で扱えるようになっています。これが変数です。

## char型の範囲が－128～127って？

　となると，変数について正しく理解しないと，目的に合った正しいプログラムを作るのは難しいですよね。変数とはどのようなものかをもう少し詳しく見ていきましょう。

　変数には「型」というものがあります。型は，その変数が(1)どのような形でデータを格納するかと，(2)一つの変数がメモリーをどれくらい必要とするかの二つを定めたものと考えてください。C言語の代表的な型と表現できる値の範囲は，表1のようになります。10年いや20年ぐらい前のことですが，筆者が初めてこのような表を目にしたとき，char型は文字を表すのに，どうして－128～127って書いてあるの？ と思いました。誰でも最初は素人なのです。

![](http://panzhifei.fun/img/2021/03/31/01/hyo01.jpg)
*表1●C言語の主な変数の型と，表現できる値の範囲*

前回，説明しましたように，コンピュータではプログラムもデータも，すべてオンとオフの2値の情報として，2進数のイメージで情報を扱います。メモリーの中に0と1がびっしり埋まっている様子を想像してください。2進数はご存じですよね。2で桁上がりする数のことです。例えば日頃使っている10進数の0，1，2，3，4を2進数で表すと0，1，10，11，100となります。この0と1の並びをどんどん，ながーく伸ばしていけば大きな値も扱えることに疑問の余地はありません[＊1](#jump1)。

コンピュータは，数値に限らず，文字も，音声も，画像も，2進数の0と1の並びで情報を扱います。コンピュータが生まれた国のアルファベットはもちろん，ひらがなも，漢字も，あらゆる文字も0と1の組み合わせで表現します。

　複数のコンピュータで互いに情報をやりとりするためには，どの文字を，どの0と1の組み合わせで表現するかをあらかじめ決めておかなければいけません。この決まりを「文字コード」といいます。

　もっとも代表的な文字コードは，ANSI（米国規格協会）が1962年に制定したASCII（アスキー）コードです[＊2](#jump2)。ASCIIコードでは，例えば1000001という7ビットの並び（16進数では41[＊3](#jump3)）がAを表し，1100001（16進数では61）はaを意味します。「1」という“文字”は0110001（16進数では31）です。表2のように，A，Bなどの可読文字だけではなく，NULやSOHなどの制御文字[＊4](#jump4)を含め128のコードが制定されています。

![](http://panzhifei.fun/img/2021/03/31/01/hyo02.jpg)
*表2●ASCIIコード表。例えば「A」は上位3ビットが4，下位4ビットが1なので，コードは16進数で41とわかる*

128種のコードなら7ビット，つまり1バイトで1ビットの余裕を持って表現できますよね。なので，C言語では文字は1バイトのchar型で表します。でも，漢字を含む日本語の文字は種類が多いので1バイトでは表現できません。WindowsではシフトJISコード，UNIX系OSではEUCコードなどの2バイトのコードを使って漢字やかなを表現します。また，近年では，1バイトで表現可能な文字も，漢字と同様に2バイトを使って表すUnicode（ユニコード）も広く使用されています。

　説明ばかりで少し退屈してきましたね。プログラムを作って，C言語で文字を変数に代入したとき，どのように扱われているかを見てみましょう。リスト1は，変数に文字や値を代入し，様々な形で標準出力（ディスプレイ）に出力してみるプログラムです。

![](http://panzhifei.fun/img/2021/03/31/01/02list01.jpg)
*リスト1●変数に文字や値を代入し，様々な形で標準出力（ディスプレイ）に出力してみる*

実行結果は**図1**です。この実行結果とリスト1のコードを照らし合わせて，char型変数の中身をイメージしていきましょう。まず，リスト1の(1)でchar型の変数を四つ宣言しています。c1，c2，c3，c4という名前（識別子）で指し示すことができる1バイトの箱を，メモリーに四つ作成したと考えてください。なお，c1，c2という変数名には特に意味はありません。C言語では英字・数字・アンダースコア（_）の組み合わせを識別子として使用できます。変数に名前を付けるときは，「数字で始めることはできない」「大文字・小文字は区別される」「C言語の予約語（例えば，intやreturn）を使うことはできない」――などの規則があることを覚えておいてください。

![](http://panzhifei.fun/img/2021/03/31/01/02zu01.jpg)
*図1●リスト1の実行結果*

リスト1の(2)でc1に「A」という文字を代入しています。C言語では文字はシングルクォーテーション（'）で区切ります。このc1の値を画面に表示するコードは，すぐ下にある(3)のprintf関数です。printf関数は書式付きで文字列を出力します。同じ値を文字として出力したり，10進数，16進数で表示することができます。

　printf関数の第1引数には文字列を指定します。文字列は，複数の文字の並びのことで，文字とは違い，ダブルクォーテーション（"）で区切ります。文字列中の%c，%x，%dなどを変換仕様といい，第2，3，4引数がこの変換仕様の部分に展開されていきます。文字として出力するには%cを，16進数として出力したい場合は%xを，10進数の整数として出力する場合は%dを指定します。第2，3，4引数はどれもc1です。図1の実行結果を見ると，

**文字：A 16進数：41 10進数：65**

と表示されていますね。文字としては「A」なのですが，メモリー内部では16進数で41，つまり2進数で01000001というビットの並びで表現されていることがわかります。

　さて，printf文の第1引数で指定した文字列の中に，画面に表示されていない文字があります。「\n」です。\nは改行を意味する「エスケープ・シーケンス」です。エスケープ・シーケンスは，画面に表示できる文字だけで，制御文字を入力するための仕組みです。\nのように，「\」と「n」を続けて入力すると改行の制御文字を表すことができます。なのでリスト1の(3)の実行を終えたところで，1行改行しているわけです。なお，「\」という文字そのものを表したい場合は，「\\」と\を二つ続けて入力します。

　(4)の\x61も，2桁の16進数で61を表すエスケープ・シーケンスです。(5)で文字として表示させると，aと表示されます。(6)と(7)は文字としての「1」の表示です。文字の1は，16進数で31，2進数で00110001というビットの並びです。

　(8)と(9)は変数c4に代入した\nを文字として出力しています。図1を見ると，「\n」と表示される代わりに，行が変わっていますね。改行を意味する制御文字を表示しようとすると，画面では改行として扱われます。\nは16進数ではa，10進数では10と表示されています。2進数では00001010です。

## 足し算で小文字を大文字に変える

　一つの英数字が，メモリー上では2進数8桁で表されているというイメージをつかむことができたでしょうか。次に，キーボードから入力した英字の大文字を小文字に変換するプログラムを考えてみましょう。

　英字の大文字はA=41（16進）からZ=5A（16進）まで，順序よく並んでいます。小文字もa=61（16進）から，お行儀よく整列しています。char型の変数といっても中味は数値ですから，文字と文字を足し算したり，引き算したりと，お互いに計算させることができます。Aとaの数値としての差と，Zとzのそれに違いはないので，入力された大文字に'a'－'A'の値を足してやれば，小文字になるはずです。

　この仕組みをプログラムとして書いたのが**リスト2**です。(1)で宣言したchar型変数cに，(3)のscanf関数で文字を入力しています。

　**scanf("%c",&c);**

の「%c」はprintf関数に指定したものと同じ変換仕様です。標準入力（キーボード）から文字を1文字読み込みます。

![](http://panzhifei.fun/img/2021/03/31/01/02list02.jpg)
*リスト2●大文字を小文字に変換する*

第2引数にある「&c」の「&」はアドレス演算子といい，指定した変数のメモリー上の場所（アドレス）を取得します。変数のアドレスについては，今後の連載でじっくりと説明しますが，scanf関数は変数という一つの箱に値を入れるときに，変数の名前ではなく，“場所を教えてくれ”と要求する関数なのだと理解してください。ともかくこのように書くと，char型の変数cに文字を読み込むことができます。

　さて，aとAの差は，リスト2の(2)でint型（整数型）の変数diffに入れています。int型は4バイトで整数を記憶するデータ型です。整数値として差異を求めることが目的なので，char型ではなくint型を使用しています。(2)のように変数は宣言と同時に値を代入し，初期化することができます。(4)では，入力された文字にdiffを足して小文字に変換しています。

　実行結果は**図2**です。「J」が「j」に変換されていますね。なお，このサンプル・プログラムでは，入力された値のチェックを行っていません。実用的なプログラムにするには，入力値が英字大文字の範囲内にあるかどうかをチェックする必要があります。

![](http://panzhifei.fun/img/2021/03/31/01/02zu02.jpg)
*図2●リスト2の実行結果*

## コンピュータは小数点以下の計算が苦手？

　ここまでは，char型（文字型）とint型（整数型）の変数を使ってきました。それぞれunsignedと付いている型は符号なしで正の値のみを扱うための型です。各変数のサイズはコンパイラやOSの種類によって異なる場合がありますが，Borland C++コンパイラで作成したプログラムは，int型は4バイト，char型は1バイトのメモリー領域を使用します。

　整数型には収まらないような大きな値や，小数点以下の値を含む実数を扱うときに，C言語ではfloatやdoubleといった浮動小数点数型を使います。科学技術計算などでよく用いられ，実際とても便利なのですが，計算すると誤差が出る場合があり注意が必要です。

　サンプル・プログラムで見てみましょう（リスト3）。0.2をfloat型の変数に111回足して，その値が22.2と等しいかどうかを調べ，等しい場合は「0.2を111回足すと，22.2になります。」と表示するものです。

![](http://panzhifei.fun/img/2021/03/31/01/02list03s.jpg)
*リスト3●浮動小数点数型の変数に0.2を111回足して，結果が22.2になるかを試す*

リスト3を読むためには，「++」など，C言語特有の演算子と制御文を理解する必要があります。リスト3の内容に入る前に簡単に解説しておきましょう。リスト3の(2)で登場する「++」は，インクリメント演算子と呼びます。「i++」と書くと，iに1を加算します。Visual Basicなどでは単純にカウンタの値を1アップさせるときでも，i = i + 1と書かなくてはならないので，「C言語みたいにi++と書ければ良いのに」と筆者は面倒に感じます。減算はデクリメント演算子を使ってi--と書きます。

　なお，インクリメント演算子とデクリメント演算子は，++iのように変数の前に記述することもできます。変数を単純にインクリメント，デクリメントするだけなら，演算子を前に置く（前置）場合と後ろに置く場合（後置）に違いはありません。でも，式の中で使う場合は注意が必要です。

　例えば，aが0のとき，後置インクリメントで

　**b = a++;**

を行うと，aの値は1になりますがbの値は0です。

　**b = ++a;**

と前置にするとaとbの両方が1になります。後置では，bにaを代入してからaをインクリメントし，前置ではaをインクリメントしてからbに代入するという違いがあるのです。

　ほかに，C言語で利用する主な演算子を表3にまとめておいたので参照してください。制御文の書き方は，コードを追いながら解説しましょう。

![](http://panzhifei.fun/img/2021/03/31/01/02hyo03.jpg)
*表3●C言語の主な演算子*

というところで，リスト3の解説に入ります。(1)でfloat型の変数fを宣言すると同時に，0を代入して初期化を行っています。(2)のfor文が0.2を111回繰り返し加算する制御文です。forのカッコの中にある「i=0;i＜111;i++」は，iが0から111より小さい間，一つずつiの値を増やしながら繰り返しをする，という意味です。なので，iが0から110まで順番に，(3)の文を繰り返し実行します。

　(3)のf+=0.2もC言語の便利な書き方で，意味は上の行にコメント[＊5](#jump5)として記述してあるように，f = f + 0.2です。もちろんf = f + 0.2と書くこともできます。減算や掛算，割り算も同様に，－＝，＊＝，／＝と記述することができます。くだくだ書かなくてもよいところが，C言語がプログラマに好まれる理由の一つかもしれません。

0.2を111回足した値が22.2と等しいかどうかを判断しているのが(4)のif文です。if文は条件分岐を行う制御文です。この例ではelseとともに記述していますので，fが22.2と等しいとき(5)の文を実行，else(それ以外)のとき(6)を実行します。＝＝は等しいかどうか比較する演算子です。比較演算子はほかにも表3のように用意されています。

　さて，このプログラムの結果はどうなるでしょうか？ 意外かもしれませんが，「0.2を111回足しても，22.2になりません。」と表示されるのです（**図3**）。何度実行しても22.2にはなりません。「0.2を111回足せば，22.2に決まっているじゃないか！」と普通，思いますよね。でも浮動小数点数型の計算では，小さな違いが出てしまうのです。

![](http://panzhifei.fun/img/2021/03/31/01/02zu03.jpg)
*図3●リスト3の実行結果*

皆さんは，1÷3が割り切れず，0.3333…という「循環小数」になることはご存じですよね。0.3333…を3回足しても1にはなりませんね。一方，1÷2は0.5ぴったりの「有限小数」です。

　今回リスト3で利用した0.2は，私たちになじみの深い10進数では有限小数ですが，実はコンピュータにとっては循環小数なのです。コンピュータの中ではあらゆる情報が2進数で扱われています。10進数ではきりのよい数値が，2進数では扱いにくい数になることがあるのです。2進数になじみがないとイメージしにくいかもしれません。あわてず，ゆっくり考えていきましょう。

　10進数の9999は，10の0乗×9 ＋ 10の1乗×9 ＋ 10の2乗×9 ＋ 10の3乗×9と表すことができます。同様に，2進数の1011は2の0乗×1 ＋ 2の1乗×1 ＋ 2の2乗×0 ＋ 2の3乗×1と表すことができます。

　10進数では桁上がりすると，10倍，100倍…となっていきます。一方，2進数の場合は2倍，4倍…です。では，小数点以下はどうなるのかと言うと，10進数では，1/10，1/100…ですから，2進数では，1/2，1/4…と半分，半分になっていくのです。ここで，10進数の0.2を2進数で表すために2進数の各桁の値を足していくと，0.001100110011…と，0011を繰り返す循環小数になってしまいます。

　このように，10進数では有限小数だった数が，2進数では循環小数になってしまうことがあるのです。というわけで浮動小数点数型を使うときは，乱暴な言い方に聞こえるかもしれませんが，「近似値を求めるのだ」と最初から割り切っておくことが必要でしょう。金属の金は，フォーナイン（999.9）で純金ですし，工業や科学技術計算では許容できる誤差があります。例えば，このサンプル・プログラムの場合，完全に一致していなくても，22.2との差が0.0001未満なら一致していると判断してもいい場合があるのです。しかし，どうしても困る分野もあります。銀行の金利計算や為替の計算では，近似値というわけにはいきません。コンピュータの都合で，誰かが損をすると困ってしまいます。

　そのために，例えばVisual Basicには通貨型（Currency）が用意されていたり，データベースにもMoney型などの正確に金額を記憶するための型があるのです。また，事務処理分野で古くから利用されてきたCOBOL言語には，BCD（Binary Coded Decimal：2進化10進数）という形式があります。BCDでは10進数の0から9までを，4桁の2進数で表現します。185は，1と8と5をそれぞれ，0001，1000，0101と表すことができます。これに小数点が何桁目の位置にあるかという情報があれば，人間と同じように10進数で計算することができるのです。

　では，そういうデータ型が用意されていないC言語ではどうすればよいのかと言うと，計算は整数で行い，計算結果を小数点以下の値を含む値に戻すという方法が考えられます。0.2を111回足した結果を表示するのなら，2を111回足して，最後に10で割って答えを出すようにすればいいのです。

# <span id="title3">第3回　制御構文がわかればプログラムの「流れ」がわかる</span>

「よくわかるC言語」，今回は連載3回目です。1回目はBorland C++コンパイラ[＊1](#jump1)のオプションを指定して，C言語のコードの1行から複数のアセンブリ・コード，つまりマシン語が出力されることを確認しました。2回目は浮動小数点数の計算に誤差が出る理由などを説明し，変数の性質を学びました。さて今回は，プログラムの構造を説明し，「C言語のプログラムはどのように書けばよいのか」を大まかに理解してもらうことを目標にします。カメラのズームをいったんぐっーと引くように，ワイドな視界でC言語のプログラミングを眺めてみましょう。

## 基本は構造化プログラミングにあり

　皆さんは「構造化プログラミング」という言葉をご存知ですか？ 1960年代後半，エドガー・ダイクストラ[＊2](#jump2)が中心となって提唱したプログラミングの考え方です。現在，主流となりつつあるオブジェクト指向プログラミングも，実は構造化プログラミングをベースとしています。

　構造化プログラミングの目的は，大規模なプログラムを効率よく作成し，プログラムのミス（バグ）を少なくすることです。そのための具体的な方法としてダイクストラは，プログラムに必要な手続きをいくつかの単位に分け，メインの処理に大まかな処理を，サブルーチンに細部の処理を記述せよと主張しました。また，プログラムは「順次」「反復」「分岐」の三つの基本構造で記述できるという構造化定理を証明し，結果として「goto文は不要である」と主張しました。

　「goto文は不要」と言われても，goto文自体を見たことがない方もいるでしょう。goto文というのは，プログラムの途中で，指定した行番号やラベルにジャンプできる制御文のことです。例えばgoto文を実装している初期のBASIC言語で書かれたプログラムは，goto文でプログラム中の行番号やラベルに飛んで，そこに記述してある処理を数行実行したあと，またgoto文でどこかへ飛んでいく――という構造になっていることが多かったのです（**図1**）。これでは，どこから来てどこへ行くのかわからないスーパーマンのようなもので，いつどのコードが実行されるのか，ロジックを追うことが難しくなります。「実行直前に他の場所に飛んでしまうので，永遠に実行されないコードがあった」なんてことも古いプログラムではよくあったのです。

![](http://panzhifei.fun/img/2021/03/31/01/03zu01.jpg)
*図1●BASICにおけるgoto文のイメージ*

そういった複雑さを読み解くことに，迷路やクイズのような楽しさを感じる方がいらっしゃるかもしれませんが，一般的に「わかりにくい」プログラムほど「迷惑」な話はありません。そこで以降は，ダイクストラの教えに従って，C言語で，

**●プログラムを複数の単位に分けて作成する**
**●順次・反復・分岐の論理構造を作る**

方法を解説していきましょう。

## 関数という単位で複数の単位に分ける

　C言語は，printf関数[＊3](#jump3)を始めとする汎用性の高い関数をライブラリ関数として標準で装備しています。しかし，装備している関数を使うだけで，すべてのプログラムを作成できるわけではありません。

　**リスト1**のCのプログラムを見てください。文字型の変数cに「文字」として0から9までの数字を代入し，printf関数に％c ，％xと変換仕様を指定して，文字と16進数を画面表示させるプログラムです（**図2**）。文法上は何の問題もありません。でも，何か冗長な感じがしませんか？先の構造化定理の中で，使っているのは「順次」，すなわちmain関数の上から下に向かって処理が実行されている部分だけですね。

![](http://panzhifei.fun/img/2021/03/31/01/03list01.jpg)
*リスト1●0から9までの「文字」と，その16進数を表示するプログラム。文字が増えればコードは長くなり，冗長である*

![](http://panzhifei.fun/img/2021/03/31/01/03zu02.jpg)
*図2●リスト1を実行した結果*

これを**リスト2**のように書き直してみるとどうでしょう？ outxという名前の自作の関数を作り(1)，main関数から呼び出すようにしてみました(2)。main関数の内部では，繰り返しを行う制御文for（後述）を使って，変数cの値が文字としての‘0’から‘9’以下の間，処理を継続させています。

![](http://panzhifei.fun/img/2021/03/31/01/03list02.jpg)
*リスト2●リスト1を関数という単位で作り直したCのプログラム*

リスト2のポイントは，

**●main関数が処理の制御を行っている**
**●outx関数が画面への値の出力を行っている**

の2点です。main関数とoutx関数の二つだけですが，プログラムを複数の単位に分けたわけです。

　このような「関数化」のメリットは何でしょう。まず「コードの量が少なくなる」という点が挙げられます。コードの量が多ければ多いほど，タイプミスなどが原因でバグが出やすくなりますから，関数化すれば間違える確率が下がります。リスト1のように「printf("%c:%x ",c,c);」を何度も書くより，「outx(c);」を1行だけ書く方が，間違えにくいですよね。

　また，処理を関数としてうまく分割してやることで「プログラムがわかりやすくなる」ことも挙げられます。「この関数ではXXXの処理を行う」とシンプルなコメントで説明できる関数を作れば，メンテナンスも容易になるでしょう。

　それでもまだメリットを実感できない方は，main関数に500～600行とコードがズラズラ記述してあるプログラムをイメージしてください。筆者ならとてもそんなコードを読みたくありません。小さなプログラムなら，1人暮らし用の小さなワンルーム・マンションのように，トイレと風呂で一つの部屋（関数），それ以外で一つの部屋，で済むこともあるでしょう。しかし家を建てる時に1階を全部ワンルームにして，キッチンも子供部屋も客間も寝室も，あろうことかトイレもバスも仕切りなしに，ぜーんぶ1部屋に収めたら，メチャクチャになりますよね。たくさんの家族が住む2世帯，3世帯住宅のような大きなプログラムだと，それに応じた部屋数（関数）が必要になることは，十分納得いただけると思います。

　とはいえ，どの部分を関数として作成するかの判断には，ある程度のプログラミング経験が必要です。初心者の方は，最初のうちは目的の処理をザッーと書いて，そのあとで同じような処理を書いてあるコードを見つけて関数にしていけばいいでしょう。それだけでも，ずっと「わかりやすい」良いプログラムになるはずです。

## C言語の関数は値渡しがデフォルト

関数の話題が出てきたので，せっかくですからC言語の関数の仕組みをもう少し掘り下げておきましょう。

　関数には値を受け取って処理を行い，その結果の値を返す仕組みが用意されています。リスト2では，main関数の前に「int」と書いてありますね。これは「型宣言」で，main関数がint型の関数であること，つまりint型の値を返すことを表しています。型について忘れてしまった方は，前回の本連載を読み返してください。

　main関数の最後で「return 0」とあるのは，return文で0を返すという意味です。C言語では，プログラムが正常終了した場合に「0」を返し，そうでない場合は違う値を返すようにプログラミングすることが多いのです。

　outx関数の型はvoidとなっていますね。voidは，この関数が値を返さないことを表します。Visual Basicプログラマの方なら，Subプロシジャのようなものだと思えばいいでしょう。

　関数の間で値を受け渡しする仕組みで重要になるのが，引数（ひきすう）です。引数には仮引数（かりひきすう）と実引数（じつひきすう）があります。リスト2で言えば，outx関数を定義した「void outx(char c)」の「char c」が仮引数で，main関数の「outx(c);」の「c」が実引数となります。つまり，関数を定義するときに指定する値が仮引数，関数を実際に呼び出す際に指定する値が実引数というわけです。

　ここで大事なことが一つ。C言語では，引数は値渡し（pass by value）で渡されるということです。変数である実引数そのものが，関数に渡されるのではなく，引数に指定した変数の「値」が関数に渡っていくのです。変数そのものが渡されるのと，変数の値が渡されることにどんな違いがあるのか，具体的に説明しましょう。

　**リスト3**のプログラムを見てください。kake関数を独自に定義し，main関数からkake関数を呼び出すプログラムです。main関数では変数aに3を，bに5を代入してkake関数を呼び出し，kake関数はaとbの値を受け取って，掛け算した結果をint型で返します。ポイントは，kake関数の中でaを2倍しているところです(1)。main関数の「printf("%d X %d = %d \n",a,b,c);」では，最初にaの値を，次にbの値を，最後にaとbを掛けた値cを表示するわけですから，「6 × 5 = 15」と表示しそうなものですよね。しかし，実行結果は図3のように「3 × 5 = 15」となるのです。kake関数側で受け取ったaを2倍しても，main関数側のaには何も影響がありません。これはいったい，どう考えればいいでしょうか？

![](http://panzhifei.fun/img/2021/03/31/01/03list03.jpg)
*リスト3●C言語の値渡しを確認するためのプログラム*

![](http://panzhifei.fun/img/2021/03/31/01/03zu03.jpg)
*図3●リスト3を実行した結果*

話は簡単です。要するに，kake関数に変数aとbのコピーが渡されたのだと思えばいいのです。コピーの値を変更しても，コピー元には何も影響はありませんよね。例えば，ワープロソフトで作成したドキュメントをネットワーク経由で他のパソコンにコピーして編集しても，コピー元のファイルには影響がないのと同じ理屈です。

　こんな風に書くと，これが当たり前のように感じられるかもしれませんが，ほかのプログラミング言語，例えばVisual Basic 6.0はC言語とまったく逆です。キーワードByValを記述して，明示的に値渡しであることを宣言しないと，main関数側のaの値も変わってしまうのです。これを参照渡し（pass by reference）と呼びます[＊4](#jump4)。この値渡しの仕組みによって，C言語では関数の独立性が高くなっています。これらの関係をまとめると図4のようになります。

![](http://panzhifei.fun/img/2021/03/31/01/03zu04.jpg)
*図4●仮引数と実引数のイメージ*

## for，while，if，switchで反復と分岐を実現する

さて，ダイクストラの「処理を分割する」教えがある程度理解できたところで，今度は「順次・反復・分岐の論理構造を作る」方法について説明しましょう。

　C言語では，決まった回数，処理を反復させるために「for文」を使います。また，ある条件が成り立つ間，処理を反復させるためには「while文」を使います。それぞれのコードの例とプログラムの流れを図示すると[図5](http://panzhifei.fun/img/2021/03/31/01/03zu05.jpg)のようになります。for文には，反復処理を行うための初期値である式1，反復すべきかどうかを評価する式2，反復回数をカウントする式3の三つのパラメータが必要ですが，while文では条件式が一つあればいいことがよくわかると思います。

![](http://panzhifei.fun/img/2021/03/31/01/03zu05.jpg)
*図5●for文とwhile文を使ったC言語のプログラムと流れ*

ちなみにC言語には，for文やwhile文のほか，do～while文という制御文もあります。while文はループを開始する前に条件をチェックするのに対し，do～while文はループ中の処理を一度実行してから，続けて処理を行うかどうか条件を判断します。

　では，実際にfor文を使ったサンプル・プログラムを見てみましょう。乱数の値によって「大当たり！」と表示するプログラムです（**リスト4**）。大きくmain関数とran10関数の二つの関数に分かれ，main関数の中でfor文を使って1から10までの値aをランダムに計算しています。条件式から10回反復することがわかると思います。

![](http://panzhifei.fun/img/2021/03/31/01/03list04.jpg)
*リスト4●for文とif文を使ったプログラム*

(1)のrandは，乱数を返す関数です。乱数の範囲は0から定数RAND_MAX以下の値になります。RAND_MAXはプリプロセッサ命令#includeでインクルードしているstdlib.hの中に定義されています。

　ran10関数は乱数発生プログラムとでも言うべきもので，

　**return rand()%10 + 1;**

で剰余演算子％を使い，rand関数が返した乱数を10で割った余りを求め，1を足しています。こうすると，1から10の範囲でランダムな数を得ることができます。

　main関数の

　**srand((unsigned) time(NULL));**

は，乱数の種（seed）を与えるものです。time関数はグリニッチ標準時（GMT）の1970年1月1日00:00:00 から現在までの経過時間を秒単位で表した値を返します。「種って何？」と言われそうですが，要するに乱数を計算するための素です。rand関数を使う前にsrand関数を実行しないと，同じ数ばかりがrand関数から返されてしまうのです。理屈で考えるよりも，やってみれば明白なので，リスト4のsrandの行を/*と*/ではさんで，コメントにして実行してみてください。同じ数ばかりが表示されるはずです

C言語でもgoto文は使えるがエラー処理に限定すべき
　ダイクストラによって「不要である」と言われてしまったgoto文ですが，実はC言語でも，goto文を使うことができます。ラベルとgoto文を使って反復するプログラムを見てみましょう。

　>リストAのコードを入力してファイルを作成し，実行してみてください。1から10までの数値が表示されます（>図A）。goto文を使ってloopとendというラベルにジャンプさせ，あたかもfor文のような反復処理を実現しているわけです。

　しかしこのコードを見て，特にメリットを感じるところがありますか？ 筆者からすれば，for文を使ってループさせた方が，よっぽど簡潔に見えます。

　goto文とラベルは，特定の処理，例えば処理の途中でエラーが発生したときに，エラー処理に飛ばすといった使い方に限定した方が良いでしょう。

![](http://panzhifei.fun/img/2021/03/31/01/03listAs.jpg)
*リストA●C言語でgoto文を使ったコード*

![](http://panzhifei.fun/img/2021/03/31/01/03zuAs.jpg)
*図A●リストAを実行した結果*

**リスト4**には，反復だけでなく，分岐の構文も登場しています。「if文」です。if文を使って，aの値が10と等しいかどうかを評価し「真」ならば「大当たり！」と表示させています（**図6**）。「これではあまりにシンプルすぎる。評価の結果で偽となったとき，別の処理を行わせたい」ということならば，「if～else文」を使えばいいでしょう。リスト4の(2)の部分を**リスト5**のように，if～else文に置き換えて実行した結果が**図7**です。

![](http://panzhifei.fun/img/2021/03/31/01/03zu06.jpg)
*図6●リスト4を実行した結果。コンパイル時に警告が出るがプログラムは実行可能*

![](http://panzhifei.fun/img/2021/03/31/01/03list05.jpg)
*リスト5●リスト4の(2)の部分をif～else文に変更したコード*



<center>☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</center>
<center><span id="title13">☆　　 　　　コメント　　　　 　☆</span></center>
<center>☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</center>

<span id="jump1">＊1 母国語は機械語（マシン語）</span>
英語と日本語の差ほどではないのですが，コンピュータやOSによって，マシン語にも違いがあります。例えば，Windows用のマシン語プログラムをUNIXマシンに持っていっても，そのまま実行させることはできません。

<span id="jump2">＊2 マシン語プログラムを16進数で</span>
2進数は，1桁で0と1の2値を表現できますが，マシン語などのダンプ表示に2進数を使うと，0と1がずらずらと並んでわかりにくくなります。そこで一般には2進数となじみのよい16進数で表記します。16進数1桁で2進数4桁を表現できます。

<span id="jump3">＊3 自然言語</span>
自然言語は，日本語や英語のように，人間が自然に使い出した言語のことです。

<span id="jump4">＊4 バグ</span>
バグはコンピュータのプログラムに含まれる誤り，欠陥のことです。

<span id="jump5">＊5 Java VM</span>
Java VMはJava Virtual Machine の略で，Javaの中間コードをマシン語に変換して実行するためのソフトウエアです。

<span id="jump6">＊6 .NET Framework</span>
.NET Frameworkは，Microsoft .NET対応アプリケーションの動作環境です。.NET Framework用の中間コードにコンパイルされたコードを，.NETFrameworkがOSごとのマシン語に変換して動かします。JavaVMとの違いは特定の開発言語に依存しないことです。米Microsoftが提供する主要な開発言語であるVisual Basic/C++/C#などのほか，Borland Delphi 8でも.NETFramework対応のプログラムを作成できます。

<span id="jump7">＊7 Windows 98におけるインストール</span>
Windows 98におけるインストールについては，日経ソフトウエアの[Webサイト](http://software.nikkeibp.co.jp/software/special/bcc_install/bcc_install.html)のWebスペシャルの情報などを参考にしてください。

<span id="jump7">＊8 src</span>
srcはsource（ソース）の略で，一般にソース・プログラムを格納するフォルダ名として利用されます。
